This "mho" directory is a standalone "sandbox" where the C++ class MHO_Unit is
being developed. This class is intended to be a part of the HOPS-4.0 project at

https://github.mit.edu/barrettj/hops-git

Specifically, the two files:

hops-git/source/cpp_src/Utilities/include/MHO_Unit.hh

hops-git/source/cpp_src/Utilities/src/MHO_Unit.cc

An objects of MHO_Unit class holds an expression of measurement units (let us
denote it as EMU or just emu).
The emus are initialized with strings in a humam-readable form. The expressions
can include spaces and parenthesis of any nesting.
For example, define:

    MHO_Unit a("m/s^2");
    MHO_Unit m("kg");
    MHO_Unit F(); // Empty expression

The class defines algebraic operations "*" and "/" between the emus, as well as
the exponentiation operation with an integer exponent "^". All thes operations
allow for their compound counterparts, "*=", "/=", and "^=". 
We can write:

    F = m*a;
    
and see the result:

    std::cout << F.GetUnitString() << std::endl;
--> m * s^-2 

We can also try this (pretty meaningless, though) operation:

    F ^= -3;
    std::cout << F.GetUnitString() << std::endl;
--> m^-3 * kg^-3 * s^6

More test examples are in the file MHO_Unit.cc, in main().
Eventually, we may include SI prefixes, like kilo, Mega, etc.


Under the Hood.

The MHO_Unit class allows for fixed number of SI units. Currently, the 12 base
units are defined in the meas_tab[NMEAS] array in the file read_units_funcs.c:

    "m", "kg", "s", "A", "K", "cd", "mol", "Hz", "rad", "deg", "sr", "Jy"

Each one has fixed position from 0 to 11. In MHO_Unit class any EMU is
represented as an int array of length 12 containing the exponents of the units.

EMUs in humam-readable strings are algebraic expressions, so they need to be
parsed. The parser repeatedly calls the lexer for the next lexeme and checks if
the sequence of lexemes matches the specified syntactic rules. In our case, the
lexemes are "kg", or "*", or "(", etc.  During this process, every matching of
the syntax rule makes the parser add to AST, the abstract syntax tree of the
expression. When it finishes, we have a link to AST containing all the units and
links between them in the source expression.
The AST then is reduced into a linked list with elements
[unit position number; it's exponent]. The function

    reduce_and_free(AST, list)

creates the list and simultaneously frees the tree memory. Finally, the function

    explst_to_arr_and_free(list, pwrs)

writes the unit exponents from the expression list into the int pwrs[12] array,
and frees the list memory. 

The lexer and parser are programs in the C language created with the generators
Flex and Bison. The programs for them are in the files read_units.l and
read_units.y. The parser function generated by Bison has the name

    yyparse(&list)

This function fulfills the steps described above to return the pointer to the
list of units. Finally, the function

    explst_to_arr_and_free(list, pwrs)

writes the unit exponents from the expression list into the int pwrs[12] array,
and frees the list memory.

The private method MHO_Unit::Parse(str) calls 
    
    yyparse(&list) and then, if there were no errors,
    explst_to_arr_and_free(list, &pwrs).

The contents of pwrs array are then copies into the private array fExp.

The program read_units.c is a pure-C variant of the parsing. To try it, rename

    mv Makefile _Makefile.bac
    mv Makefile_for_read_units.c.txt Makefile






